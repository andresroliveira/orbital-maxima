/* src/utils.mac */

/* Função principal que roda tudo */
run_simulation(duration) := block(
    [accels, ar_num, at_num, r0, v0, init_state, sol, xy_points],
    
    print("1. Derivando física..."),
    accels: get_accelerations(),
    
    /* Prepara para RKF45 */
    ar_num: subst([diff(r,t)=vr, diff(theta,t)=w, r=r, theta=th], accels[1]),
    at_num: subst([diff(r,t)=vr, diff(theta,t)=w, r=r, theta=th], accels[2]),
    
    /* Condições Iniciais (LEO) */
    r0: float(R_earth + 400000),
    v0: float(sqrt(G_const * M_earth / r0)) * 1.1, /* Levemente elíptico */
    init_state: [r0, 0.0, 0.0, v0/r0],
    
    print("2. Integrando trajetória..."),
    sol: rkf45(
        [vr, ar_num, w, at_num], 
        [r, vr, th, w], 
        init_state, 
        [t, 0, duration],
        absolute_tolerance=1e-8
    ),
    
    print("3. Gerando dados de plotagem..."),
    xy_points: map(lambda([row], [row[2]*cos(row[4]), row[2]*sin(row[4])]), sol),
    
    /* Retorna os pontos para quem chamou poder plotar ou salvar */
    return(xy_points)
)$

/* Função auxiliar de plotagem */
plot_trajectory(points_data) := draw2d(
    title = "Orbita Modular",
    user_preamble = "set grid; set size square;",
    color = blue, points([[0,0]]), key="Terra",
    color = red, points_joined=true, point_size=0, key="Satélite",
    points(points_data)
)$
