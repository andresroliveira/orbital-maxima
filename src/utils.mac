/* src/utils.mac  */

run_simulation(duration) := block(
    [accels, ar_num, at_num, r0, v0, init_state, sol, xy_points],
    
    print("1. Derivando física..."),
    accels: get_accelerations(),
    
    /* Prepara equações */
    ar_num: subst([diff(r,t)=vr, diff(theta,t)=w, r=r, theta=th], accels[1]),
    at_num: subst([diff(r,t)=vr, diff(theta,t)=w, r=r, theta=th], accels[2]),
    
    /* Condições Iniciais (Altitude 400km) */
    r0: float(R_earth + 400*1000),
    v0: float(sqrt(G_const * M_earth / r0)) * 1.2, /* 1.2x = Elipse */
    init_state: [r0, 0.0, 0.0, v0/r0],
    
    print("2. Integrando trajetória..."),
    sol: rkf45(
        [vr, ar_num, w, at_num], 
        [r, vr, th, w], 
        init_state, 
        [t, 0, duration],
        absolute_tolerance=1e-8
    ),
    
    print("3. Convertendo Metros -> Kilômetros..."),
    xy_points: map(
        lambda([row], [ (row[2]*cos(row[4]))/1000.0, (row[2]*sin(row[4]))/1000.0 ]), 
        sol
    ),
    
    return(xy_points)
)$

plot_trajectory(points_data) := draw2d(
    title = "Simulador Orbital",
    xlabel = "x (km)",
    ylabel = "y (km)",
    
    /* Trava a proporção 1:1 entre os eixos */
    proportional_axes = xy,
    
    xrange = [-20000, 20000],
    yrange = [-20000, 20000],

    user_preamble = "set grid",
    /* 1. DESENHAR A TERRA (Azul Sólido) */
    
    fill_color = blue,
    color = blue,
    /* ellipse(centro_x, centro_y, raio_x, raio_y, angulo_ini, angulo_fim) */
    ellipse(0, 0, 6371, 6371, 0, 360),
    
    /* 2. DESENHAR A ÓRBITA (Linha Vermelha) */
    color = red,
    key = "Satelite",
    points_joined = true,
    point_size = 0,
    line_width = 2,
    points(points_data)
)$
